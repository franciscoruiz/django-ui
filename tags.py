"""
Class-based template tags for Django.

TODO:
 - Provide sensible default value for 'next_blocks'.
 - Review name for block: block, keyword, header?
 - Add a method that outputs autogenerated documentation with the tag structure.
 - Which is the best way to define the closing keyword? Implicit vs. explicit.

"""
from functools import wraps

from django.template.base import Node
from django.template.base import TemplateSyntaxError
from django.template.base import Variable
from django.template.defaulttags import token_kwargs
from django.template.loader import render_to_string
from django.utils.safestring import mark_safe


#{ Base classes


class Tag(Node):
    """
    Base class for Django template tags.
    
    The output will be the sum of every processed block.
    
    """
    
    resolve_block_parameters = True
    """
    Whether blocks parameters will be resolved as variables in the context
    of the template.
    
    """
    
    def __init__(self, parser, token):
        self.parser = parser
        self.template_context = None

        self.blocks = self.__class__._parse_blocks(parser, token)

    def render(self, context):
        self.template_context = context

        output = mark_safe('')
        for processor, args, kwargs, body in self.blocks:
            output += processor(self, body, *args, **kwargs)
        return output
    
    @classmethod
    def _parse_blocks(cls, parser, token):
        """
        Return a list of tag blocks as found in the template.
        
        Each block will be defined as:
        
        (block_processor, block_arguments, block_kwargs, block_body)
        
        """
        blocks = []
        
        # Process first block
        block_arguments = token.split_contents()
        block_keyword = block_arguments.pop(0)
        
        processors = cls._get_declared_blocks()
        closing_keyword = 'end_' + block_keyword
        while(True):
            print 
            try:
                block_processor = processors[block_keyword]
            except KeyError:
                raise TemplateSyntaxError(
                    'Block %r not found, candidates are %r' % 
                        (block_keyword, block_processor._next_blocks)
                    )
            
            # Parse token keyword arguments if necessary
            if cls.resolve_block_parameters:
                # The parsed keyword arguments are removed from the original
                # list
                block_kwargs = token_kwargs(block_arguments, parser)
            else:
                block_kwargs = {}
            
            # Parse the body of the block
            next_blocks = _MultiBlockTagPrefixes(block_processor._next_blocks)
            block_body = parser.parse(next_blocks)
            
            blocks.append(
                (block_processor, block_arguments, block_kwargs, block_body))

            # Parse next block
            token = parser.next_token()
            block_arguments = token.split_contents()
            block_keyword = block_arguments.pop(0)
            
            if block_keyword == closing_keyword:
                break

        return blocks

    @classmethod
    def _get_declared_blocks(cls):
        """Return the tag blocks declared in the class."""
        return {
            method._block_name: method
                for method in cls.__dict__.values()
                if callable(method) and hasattr(method, '_block_name')
            }


class _MultiBlockTagPrefixes(list):
    """
    Collection of tag prefixes to be considered part of a multi-block tag.
    
    """

    def __contains__(self, block):
        """Return whether a contained element is the prefix of ``block``"""
        return any(block.startswith(prefix) for prefix in self)


def tag_block(name=None, next_blocks=None):
    """
    Declare a tag block.
    
    :param `name`: Name of the tag block. If it's not specified,
        the method name will be used.
    :param `next_blocks`: Collection of blocks (by name) allowed after
        this block. The implicitly-defined closing tag must be included
        if the block can be found as the last one.

    """

    def _actual_wrapper(processor):
        @wraps(processor)
        def processor_wrapper(tag_instance, block, *args, **kwargs):
            if tag_instance.__class__.resolve_block_parameters:
                # Resolve variables in the template context
                resolve = lambda variable: \
                    Variable(variable).resolve(tag_instance.template_context)
                
                args = tuple(resolve(arg) for arg in args)
                kwargs = {key: resolve(value) for key, value in kwargs.items()}
            
            return processor(tag_instance, block, *args, **kwargs)
        
        # Register the block name
        processor_wrapper._block_name = name or processor.__name__
        processor_wrapper._next_blocks = next_blocks
        
        return processor_wrapper
    
    return _actual_wrapper


#{ Base class for inclusion tags


class InclusionTag(Tag):
    """
    Invoke every block processor and render ``template_name`` with the
    (potentially altered) template context.
    
    The block processing methods (decorated with :func:`tag_block`) must
    return a dictionary-like object as their addition to the template
    context.

    """

    template_name = None
    """Name of the template that will be rendered."""

    def render(self, context):
        self.template_context = context

        # Process every block
        for processor, args, kwargs, body in self.blocks:
            context_addition = processor(self, body, *args, **kwargs)
            context.update(context_addition)
        return render_to_string(self.template_name, context)

    
#}

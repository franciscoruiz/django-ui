"""
Class-based template tags for Django.

TODO:
 - Provide sensible default value for 'next_blocks'.
 - Review name for block: block, keyword, header?
 - Add a method that outputs autogenerated documentation with the tag structure.
 - Which is the best way to define the closing keyword? Implicit vs. explicit.

"""
from collections import OrderedDict
from functools import wraps

from django.template.base import Node
from django.template.base import TemplateSyntaxError
from django.template.base import Variable
from django.template.defaulttags import token_kwargs
from django.template.loader import render_to_string
from django.utils.safestring import mark_safe


#{ Base classes


class Tag(Node):
    """
    Base class for Django template tags.
    
    The output will be the sum of every processed block.
    
    """

    resolve_block_parameters = True
    """
    Whether blocks parameters will be resolved as variables in the context
    of the template.
    
    """

    def __init__(self, parser, token):
        self.parser = parser
        self.template_context = None

        self.blocks = self.__class__._parse_blocks(parser, token)

    def render(self, context):
        """
        Set the rendering context and invoke the block processors as
        found in the template.
        
        """
        self.template_context = context

        output = mark_safe('')
        for processor, args, kwargs, body in self.blocks.values():
            output += processor(self, body, *args, **kwargs)
        return output

    @classmethod
    def _parse_blocks(cls, parser, token):
        """
        Return an :class:`OrderedDict` of tag blocks as found in the template.
        
        Each block will be defined as:
        
        keyword: (processor, arguments, kwargs, body)
        
        """
        blocks = OrderedDict()

        # Process first block
        block_arguments = token.split_contents()
        block_keyword = block_arguments.pop(0)

        processors = cls._get_declared_blocks()
        closing_keyword = 'end_' + block_keyword
        while(True):
            try:
                block_processor = processors[block_keyword]
            except KeyError:
                raise TemplateSyntaxError(
                    'Block %r not found, candidates are %r' %
                        (block_keyword, block_processor._next_blocks)
                    )

            # Parse token keyword arguments if necessary
            if cls.resolve_block_parameters:
                # The parsed keyword arguments are removed from the original
                # list
                block_kwargs = token_kwargs(block_arguments, parser)
            else:
                block_kwargs = {}

            # Parse the body of the block
            next_blocks = _MultiBlockTagPrefixes(block_processor._next_blocks)
            block_body = parser.parse(next_blocks)

            blocks[block_keyword] = (
                (block_processor, block_arguments, block_kwargs, block_body))

            # Parse next block
            token = parser.next_token()
            block_arguments = token.split_contents()
            block_keyword = block_arguments.pop(0)

            if block_keyword == closing_keyword:
                break

        return blocks

    @classmethod
    def _get_declared_blocks(cls):
        """Return the tag blocks declared in the class."""
        return {
            method._block_name: method
                for method in cls.__dict__.values()
                if callable(method) and hasattr(method, '_block_name')
            }


class _MultiBlockTagPrefixes(list):
    """
    Collection of tag prefixes to be considered part of a multi-block tag.
    
    """

    def __contains__(self, block):
        """Return whether a contained element is the prefix of ``block``"""
        return any(block.startswith(prefix) for prefix in self)


def tag_block(name=None, next_blocks=None):
    """
    Declare a tag block.
    
    :param `name`: Name of the tag block. If it's not specified,
        the method name will be used.
    :param `next_blocks`: Collection of blocks (by name) allowed after
        this block. The implicitly-defined closing tag must be included
        if the block can be found as the last one.

    """

    def _actual_wrapper(processor):
        @wraps(processor)
        def processor_wrapper(tag_instance, block, *args, **kwargs):
            if tag_instance.__class__.resolve_block_parameters:
                # Resolve variables in the template context
                args = tuple(
                    Variable(arg).resolve(tag_instance.template_context)
                        for arg in args
                    )
                kwargs = {
                    key: value.resolve(tag_instance.template_context)
                        for key, value in kwargs.items()
                    }

            return processor(tag_instance, block, *args, **kwargs)

        # Register the block name
        processor_wrapper._block_name = name or processor.__name__
        processor_wrapper._next_blocks = next_blocks

        return processor_wrapper

    return _actual_wrapper


#{ Base class for inclusion tags


class InclusionTag(Tag):
    """
    Invoke every block processor and render ``template_name`` with the
    (potentially altered) template context.
    
    The block-processing methods (decorated with :func:`tag_block`) must
    return a dictionary-like object as their addition to the template
    context.

    """

    template_name = None
    """Name of the template that will be rendered."""

    def render(self, context):
        self.template_context = context

        # Update the context with the result of every block processor
        for processor, args, kwargs, body in self.blocks.values():
            context_addition = processor(self, body, *args, **kwargs)
            context.update(context_addition)
        return render_to_string(self.template_name, context)


#}
